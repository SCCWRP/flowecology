---
self_contained: yes
output: 
  html_document:
    includes:
      in_header: cssloaders_in_header.html
runtime: shiny
---

## Stream community response to climate change in the LA river basin {.tabset .tabset-pills}

```{r setup, include = FALSE}
# globals
library(knitr)
opts_chunk$set(echo = F, message = F, warning = F)

library(tidyverse)
library(sf)
library(mapview)
library(shiny)
library(leaflet)
library(stargazer)
library(shinycssloaders)
library(shinyWidgets)
library(patchwork)

if (is.null(suppressMessages(webshot:::find_phantom()))) { webshot::install_phantomjs() }

source('R/funcs.R')

# rmd downloads
downloadButtonRmd <- function (outputId, label = "Download", class = NULL, ...)  {
  tags$a(id = outputId, class = paste("btn btn-default shiny-download-link", 
                                      class), href = "", target = "_blank", download = NA, 
         icon("download"), label, ...)
}

data(biodat)
data(rchdat)
data(allrchdat)
data(obsbiomet)
data(futest)
data(bsest)
data(wshed)

# color palette function for prob map
pal <- colorNumeric(
  palette = RColorBrewer::brewer.pal(11, 'RdYlBu'),
  na.color = NA,
  domain = c(0, 1)
)

# species choices
spls <- list('arroyo chub' = 'chub', 'arroyo toad' = 'toad', "least bell's vireo" = 'vireo', 'rainbow trout' = 'trout', 'santa ana sucker' = 'sucker', 'southwestern pond turtle' = 'turtle')

# baseline condition choices
bstypls <- list(`dry (2014)` = '2014', `moderate (2010)` = '2010', `wet (1993)` = '1993')

# watershed choices
sheds <- allrchdat %>% 
  pull(shed) %>% 
  levels

# map types
mptyps <- c("CartoDB.Positron", "CartoDB.DarkMatter", "OpenStreetMap", "Esri.WorldImagery", "OpenTopoMap")

# ggplot theme for dist plots
pdstthm <- theme_bw(base_family = 'serif', base_size = 16) + 
  theme(
    axis.title.x = element_blank(), 
    axis.text.x = element_text(hjust = 1, angle = 20)
  )

# spelling::spell_check_files('index.Rmd')
```

```{r banner, width = "100%", fig.align = 'center'}
knitr::include_graphics('banner.png')
```

```{r reactives}
# species selection
sprct <- reactive({
  
  # input
  spsel <- input$spsel
  sheds <- input$sheds
  
  out <- biodat %>% 
    filter(spp %in% spsel) %>% 
    filter(shed %in% sheds)
  
  return(out)
  
})

# watershed selection
wshedsel <- reactive({
  
  # input
  sheds <- input$sheds
  
  out <- wshed %>% 
    filter(shed %in% sheds)
  
  return(out)
  
})

# reaches filtered by wshed
rchdatsel <- reactive({
  
  # inputs
  sheds <- input$sheds
  
  out <- rchdat %>% 
    filter(shed %in% sheds)
  
  return(out)
  
})

# all reaches filtered by wshed
allrchdatsel <- reactive({
  
  # inputs
  sheds <- input$sheds
  
  out <- allrchdat %>% 
    filter(shed %in% sheds)
  
  return(out)
  
})

# map of species data
spmap <- reactive({
  
  # input
  sprct <- sprct()
  rchdatsel <- rchdatsel()
  wshedsel <- wshedsel()
  
  validate(
    need(nrow(wshedsel) > 0, "No selection to show - select watersheds from above")
  )
  
  # get pt size
  occex <- sprct$occex
  
  # colors
  cols <- c('tomato1', 'lightgreen')
  names(cols) <- c('absent', 'present')
  
  out <- mapview(wshedsel, homebutton = F, legend = F, color = 'black', col.regions = 'white', alpha = 0.6, map.types = mptyps) + 
    mapview(rchdatsel, homebutton = F, color = 'black', legend = F, lwd = 0.5, alpha = 0.5, layer = 'Reaches') + 
    mapview(sprct, zcol = 'occurrence', legend = T, col.regions = cols, cex = occex, homebutton = F, layer = 'Occurrence')

  return(out)
 
})

# metric data joined with biodat, biodat COMIDs filtered by rchdat COMID
spmtdat <- reactive({
  
  # input
  metsel <- input$metsel
  mettypobs <- input$mettypobs
  spsel <- input$spsel
    
  # minor format for output
  out <- obsbiomet %>% 
    filter(mettypobs %in% !!mettypobs) %>%
    filter(spp %in% spsel) %>% 
    filter(met %in% metsel) %>% 
    mutate(
      occurrence = factor(occurrence, levels = c('0', '1'), labels = c('absent', 'present')),
      occurrbin = case_when(
        occurrence %in% 'absent' ~ 0, 
        occurrence %in% 'present' ~ 1
      )
    ) 
  
  req(nrow(out) > 0)
  
  return(out)
  
})

# metric and biodata plot
spmtplt <- reactive({
  
  # input
  spmtdat <- spmtdat()
  metsel <- input$metsel
  
  req(metsel)

  p <- ggplot(spmtdat, aes(x = val, y = as.numeric(occurrbin))) +
    geom_point(aes(fill = occurrence), size = 4, alpha = 0.7, pch = 21) +
    scale_fill_manual('Occcurence', values = c('tomato1', 'lightgreen'), drop = FALSE) +
    geom_smooth(method = "glm", method.args = list(family = "binomial"), fullrange = T) +
    theme_bw(base_family = 'serif', base_size = 20) +
    theme(
      legend.title = element_blank(),
      strip.background = element_blank(),
      legend.position = 'top'
      ) +
    ylab('Pr. occurrence') + 
    xlab(metsel)
  
  return(p)
  
})

# regression mod for spmtplt and stargazer
spmtmod <- reactive({
  
  # inputs
  spmtdat <- spmtdat()
  metsel <- input$metsel
  
  # trailing underscore for a metric breaks html stargazer
  metsel <- gsub('\\_$', '', metsel)
  
  # rename val to metric name for stargazer
  tomod <- spmtdat
  names(tomod)[names(tomod) %in% 'val'] <- metsel
  
  # make model
  mod <- paste('occurrbin', '~', metsel) %>% 
    as.formula %>% 
    glm(., tomod, family = 'binomial')
  
  return(mod)
  
})

# probability of occurrence predictions for species and baseline condition
bsprds <- reactive({

  # input
  spsel <- input$spsel
  bsmettyp <- input$bsmettyp
  bstyp <- input$bstyp
  rchdatsel <- rchdatsel()
  
  # filter baseline predictions
  out <- bsest %>% 
    filter(spp %in% spsel) %>% 
    filter(dts %in% bstyp) %>% 
    filter(bsmettyp %in% !!bsmettyp)
  
  # join with rchdatsel for filter
  out <- rchdatsel %>% 
    left_join(out, by = 'COMID')
  
  return(out)

})

# map of predictions by comid
bsprdsmap <- reactive({

  # input
  bsprds <- bsprds()
  wshedsel <- wshedsel()

  validate(
    need(nrow(bsprds) > 0, "No selection to show - select watersheds from above")
  )
  
  mapview(bsprds, layer.name = NULL) %>%
    .@map   %>% 
    clearMarkers() %>%
    clearShapes() %>%
    clearControls() %>%
    addPolygons(data = wshedsel(), opacity = 1, weight = 1, color = 'black', 
      fillOpacity = 0.6, fillColor = 'white', label = ~as.character(shed)
      ) %>% 
    addPolylines(data = bsprds, opacity = 1, weight = 1, color = ~pal(prd),
      label = ~as.character(round(prd, 2))
      ) %>% 
    addLegend(data = bsprds, "topright", pal = pal, values = ~prd,
              title = "Pr. occurence", opacity = 1
    )

})

# plot of baseline prediction distributions
bsprdsdst <- reactive({
  
  # inputs
  bsprds <- bsprds()

  validate(
    need(nrow(bsprds) > 0, "No selection to show - select watersheds from above")
  )
  
  # data to plot, plus median by group and all
  toplo <- bsprds %>%
    st_set_geometry(NULL) %>% 
    group_by(shed) %>% 
    mutate(
      medv = median(prd, na.rm = T)
      ) %>% 
    ungroup %>% 
    mutate(
      medvall = median(prd, na.rm = T)
      )
  
  # all 
  p1 <- ggplot(toplo, aes(x = 'All selected', y = prd, fill = medvall)) + 
    geom_violin(alpha = 0.8, colour = 'lightgrey') + 
    geom_boxplot(width = 0.1, fill = 'white', alpha = 0.1, outlier.shape = NA) + 
    labs(y = "Pr. occurrence") +
    scale_y_continuous(limits = c(0, 1)) +
    scale_fill_gradientn(colours = pal(seq(0, 1, length = 11)), limits = c(0, 1), guide = F) +
    pdstthm  
  
  # by watersheds
  p2 <- ggplot(toplo, aes(x = shed, y = prd, fill = medv)) + 
    geom_violin(alpha = 0.8, colour = 'lightgrey') + 
    geom_boxplot(width = 0.1, fill = 'white', alpha = 0.1, outlier.shape = NA) + 
    labs(y = NULL) +
    scale_y_continuous(limits = c(0, 1)) +
    scale_fill_gradientn(colours = pal(seq(0, 1, length = 11)), limits = c(0, 1), guide = F) +
    pdstthm
    
  p1 + p2 + plot_layout(ncol = 2, widths = c(0.2, 0.8))
  
})

# table data for baseline prediction distributions
bsprdstab <- reactive({
  
  # inputs
  bsprds <- bsprds()
  
  bsprds <- bsprds %>% 
    st_set_geometry(NULL)
  
  # all data summarized
  totaball <- bsprds %>%
    select(prd) %>% 
    summarise_all(funs(mean, median, min, max), na.rm = T) %>% 
    mutate(Watershed = 'All selected') %>% 
    select(Watershed, everything())
  
  # by shed
  totab <- bsprds %>%
    select(shed, prd) %>% 
    group_by(shed) %>% 
    summarise_all(funs(mean, median, min, max), na.rm = T) %>% 
    mutate(shed = as.character(shed)) %>% 
    rename(Watershed = shed) %>% 
    bind_rows(totaball, .) 
  
  return(totab)
  
})

# future predictions for selection
futprds <- reactive({
  
  # input
  spsel <- input$spsel
  clmmod <- input$clmmod
  futyr <- input$futyr
  futmettyp <- input$futmettyp
  allrchdatsel <- allrchdatsel()

  # filter predictions by selection
  out <- futest %>% 
    filter(spp %in% spsel) %>% 
    filter(mds %in% clmmod) %>% 
    filter(dts %in% futyr) %>% 
    filter(mettyp %in% futmettyp)
  
  # join with allrchdatsel for filter
  out <- allrchdatsel %>% 
    inner_join(out, by = 'COMID')
  
  return(out)
  
})

# map of predictions by comid 
futprdsmap <- reactive({
  
  # input
  futprds <- futprds()
  wshedsel <- wshedsel()

  validate(
    need(nrow(futprds) > 0, "No selection to show - select watersheds from above")
  )
  
  mapview(futprds, layer.name = NULL) %>% 
    .@map %>% 
    clearMarkers() %>%
    clearShapes() %>%
    clearControls() %>%
    addPolygons(data = wshedsel(), opacity = 1, weight = 1, color = 'black', 
      fillOpacity = 0.6, fillColor = 'white', label = ~as.character(shed)
      ) %>% 
    addPolylines(data = futprds, opacity = 1, weight = 1, color = ~pal(prd),
      label = ~as.character(round(prd, 2))
      ) %>%
    addLegend(data = futprds, "topright", pal = pal, values = ~prd,
              title = "Pr. occurence", opacity = 1
    )

})

# plot of fture prediction distributions
futprdsdst <- reactive({
  
  # inputs
  futprds <- futprds()

  validate(
    need(nrow(futprds) > 0, "No selection to show - select watersheds from above")
  )
    
  # data to plot, plus median by group and all
  toplo <- futprds %>%
    st_set_geometry(NULL) %>% 
    group_by(shed) %>% 
    mutate(
      medv = median(prd, na.rm = T)
      ) %>% 
    ungroup %>% 
    mutate(
      medvall = median(prd, na.rm = T)
      )
  
  # all 
  p1 <- ggplot(toplo, aes(x = 'All selected', y = prd, fill = medvall)) + 
    geom_violin(alpha = 0.8, colour = 'lightgrey') + 
    geom_boxplot(width = 0.1, fill = 'white', alpha = 0.1, outlier.shape = NA) + 
    labs(y = "Pr. occurrence") +
    scale_y_continuous(limits = c(0, 1)) +
    scale_fill_gradientn(colours = pal(seq(0, 1, length = 11)), limits = c(0, 1), guide = F) +
    pdstthm  
  
  # by watersheds
  p2 <- ggplot(toplo, aes(x = shed, y = prd, fill = medv)) + 
    geom_violin(alpha = 0.8, colour = 'lightgrey') + 
    geom_boxplot(width = 0.1, fill = 'white', alpha = 0.1, outlier.shape = NA) + 
    labs(y = NULL) +
    scale_y_continuous(limits = c(0, 1)) +
    scale_fill_gradientn(colours = pal(seq(0, 1, length = 11)), limits = c(0, 1), guide = F) +
    pdstthm
    
  p1 + p2 + plot_layout(ncol = 2, widths = c(0.2, 0.8))
  
})

# table data for future prediction distributions
futprdstab <- reactive({
  
  # inputs
  futprds <- futprds()
  
  futprds <- futprds %>% 
    st_set_geometry(NULL)
  
  # all data summarized
  totaball <- futprds %>%
    select(prd) %>% 
    summarise_all(funs(mean, median, min, max), na.rm = T) %>% 
    mutate(Watershed = 'All selected') %>% 
    select(Watershed, everything())
  
  # by shed
  totab <- futprds %>%
    select(shed, prd) %>% 
    group_by(shed) %>% 
    summarise_all(funs(mean, median, min, max), na.rm = T) %>% 
    mutate(shed = as.character(shed)) %>% 
    rename(Watershed = shed) %>% 
    bind_rows(totaball, .) 
  
  return(totab)
  
})
```

```{r downloadhandlers}
# map for observed species
output$dlspmap <- downloadHandler(
  filename = function(){'spmap.png'},
  content = function(file){
    mapshot(x = spmap(), file = file)
  }
)

# data for observed species
output$dlspdat <- downloadHandler(
  filename = function(){'spdat.csv'},
  content = function(file){
    # format for ambiguity
    todl <- sprct() %>% 
      st_set_geometry(NULL) %>% 
      group_by(spp, yr, shed, occurrence) %>% 
      summarise(count = n()) %>% 
      arrange(shed, yr, occurrence)
    write.csv(todl, file, quote = T, row.names = F)
  }
)

# plot for baseline prediction distributions
output$dlspmtplt <- downloadHandler(
  filename = function(){'spmtplt.png'},
  content = function(file){
    png(file, width = 7, height = 7, family = 'serif', units = 'in', res = 250)
    print(spmtplt())
    dev.off()
  }
)

# map for baseline predictions
output$dlbsprdsmap <- downloadHandler(
  filename = function(){'bsprdsmap.png'},
  content = function(file){
    mapshot(x = bsprdsmap(), file = file)
  }
)

# map data for baseline predictions
output$dlbsprdsdat <- downloadHandler(
  filename = function(){'bsprdsdat.csv'},
  content = function(file){
    todl <- bsprds() %>% st_set_geometry(NULL)
    write.csv(todl, file, quote = T, row.names = F)
  }
)

# plot for baseline prediction distributions
output$dlbsprdsdst <- downloadHandler(
  filename = function(){'bsprdsdst.png'},
  content = function(file){
    png(file, width = 10, height = 5, family = 'serif', units = 'in', res = 250)
    print(bsprdsdst())
    dev.off()
  }
)

# table data for baseline prediction distributions
output$dlbsprdstab <- downloadHandler(
  filename = function(){'bsprdstab.csv'},
  content = function(file){
    write.csv(bsprdstab(), file, quote = T, row.names = F)
  }
)

# map for future predictions
output$dlfutprdsmap <- downloadHandler(
  filename = function(){'futprdsmap.png'},
  content = function(file){
    mapshot(x = futprdsmap(), file = file)
  }
)

# map data for future predictions
output$dlfutprdsdat <- downloadHandler(
  filename = function(){'futprdsdat.csv'},
  content = function(file){
    todl <- futprds() %>% st_set_geometry(NULL)
    write.csv(todl, file, quote = T, row.names = F)
  }
)

# plot for future prediction distributions
output$dlfutprdsdst <- downloadHandler(
  filename = function(){'futprdsdst.png'},
  content = function(file){
    png(file, width = 10, height = 5, family = 'serif', units = 'in', res = 250)
    print(futprdsdst())
    dev.off()
  }
)

# table data for future prediction distributions
output$dlfutprdstab <- downloadHandler(
  filename = function(){'futprdstab.csv'},
  content = function(file){
    write.csv(futprdstab(), file, quote = T, row.names = F)
  }
)
```

```{r topsels}
column(12,

  column(4,
 
    # select species to show
    selectInput("spsel", "Choose species:", choices = spls)
    
  ),
  
  column(4,
    
    # select watershed
    pickerInput("sheds", label = 'Select watershed(s):', choices = sheds,
        options = list(`actions-box` = TRUE, size = 20), selected = sheds, multiple = TRUE)
    
  )
)    
```

### Overview

This website is an interactive tool to demonstrate riparian and stream community responses to changes in hydrology in the Los Angeles and Ventura County watersheds, California, USA.  Biological response was modeled as a function of baseline and projected changes in temperature and flow using historical data and expected flow changes from down-scaled climate change models. This website is provided to enhance understanding of climate change effects on riparian dependent species to facilitate management of watershed, riparian, and in-stream habitats. 

#### Objectives and approach 

The objective of this website is to present the project results in a way that is meaningful to the interests of the advisory committee and others that can benefit from this project.  The website is designed to address the following questions:

* What historical biological or baseline flow data are relevant for regulatory or management communities to understand current conditions? 

* What changes in biological communities and flow are relevant for regulatory or management decisions in the region?

* What sources of uncertainty are of most concern to inform decision-making processes?

The website is structured following an analysis workflow that describes the biology, modeled biological response to current conditions, and modeled biological response to future changes. Data can viewed using different selection widgets and downloaded in tabular or graphical format. __The tabs at the top of the website link to separate components of the analysis.__

1) __Observed biology__: View and download biology data for the region, including summarized historical data from existing surveys.  The modeled species responses to flow and temperature metrics can also be viewed.

1) __Baseline conditions__: View results for baseline conditions and modeled species results for stream reaches in the study region. Graphical and tabular summaries by watershed are also provided.

1) __Future scenarios__: View results for future scenarios and modeled species results for stream reaches in the study region. Graphical and tabular summaries by watershed are also provided.

#### Attribution

All site content and analyses by [Marcus Beck](mailto:marcusb@sccwrp.org), with assistance from [Jenny Taylor](mailto:jennyt@sccwrp.org), [Abel Santana](mailto:abels@sccwrp.org), and [Eric Stein](mailto:erics@sccwrp.org). View the web page source content [here](https://github.com/SCCWRP/flowecology).

### Observed biology {.tabset}

#### Map

This map shows the observed data for `r renderText({input$spsel})` from field surveys used in the study.  The points show presence (green) and absence (red) for all survey years (`r renderText({min(sprct()$yr, na.rm = T)})` to `r renderText({max(sprct()$yr, na.rm = T)})`).  A screenshot of the map or a tabular summary of the data can be downloaded by clicking the buttons below. 

```{r}
# mapview
output$spmap <- renderLeaflet({spmap()@map})
```
```{r}
column(12, 
  column(4, downloadButtonRmd('dlspmap', 'Download map')),
  column(4, downloadButtonRmd('dlspdat', 'Download data'))
)
HTML('<br>')
HTML('<br>')
column(12, 
  leafletOutput('spmap', height = 700) %>% withSpinner()
)
```

#### Modeled response

The plot on the left shows the likelihood of observing `r renderText({input$spsel})` across a range of values for the `r renderText({tolower(input$mettypobs)})` metric `r renderText({input$metsel})`.  The curve in the plot shows the estimated probability for a given value of `r renderText({input$metsel})` on the-axis, with a 95% confidence interval.  The points on the top and bottom indicate species presence/absence located on the actual values for the metric at which the data were observed.  The table on the right provides a summary of the model in the plot.  The slope and intercept estimates are shown in the first two rows (with standard error in parentheses) and the overall model summary statistics are shown in the bottom three rows.  Click the button on the bottom right to download the figure. 

```{r}
column(width = 12,

  column(width = 4,
        
        # select metric type
        selectInput("mettypobs", "Select predictor type:", choices = c('Flow', 'Temperature'))
  
  ),
  
  column(width = 4, 
        
        renderUI({
          
          # input
          mettypobs <- input$mettypobs
          spsel <- input$spsel

          # pull metrics to select based on input
          tosel <- obsbiomet %>%
            filter(mettypobs %in% !!mettypobs) %>% 
            filter(spp %in% spsel) %>% 
            pull(met) %>% 
            unique
        
          selectInput("metsel", "Select meric:", choices = tosel)
          
        })
        
  )
       
)
```

```{r}
output$spmtplt <- renderPlot({spmtplt()}, width = 500, height = 500)
output$spmtmodtab <- renderUI({
      
  # input
  spmtmod <- spmtmod()
  
  spmtmod %>%
    stargazer(., type = 'html', dep.var.labels = 'presence/absence') %>% 
    HTML
  
})
```
```{r}
column(12,
  column(width = 6, 
    plotOutput('spmtplt') %>% withSpinner()
  ), 
  column(width = 6,
    HTML('<br>'),
    uiOutput('spmtmodtab') %>% withSpinner(),
    HTML('<br><br>'), 
    downloadButtonRmd('dlspmtplt', 'Download figure')
  )
)
```

### Baseline conditions {.tabset}

```{r}
column(width = 12,

    column(width = 4,

          # select prediction type
          selectInput("bsmettyp", 'Select prediction type:', choices = c("Temperature" = 'temp', "Flow" = 'flow', 'Synthesis' = 'syn'), selected = 'syn')

    ),

    column(width = 4,
          
          # select baseline conditions
          selectInput('bstyp', 'Select baseline conditions:', choices = bstypls)

    )

)
```
```{r}
output$bsprdsmap <- renderLeaflet({bsprdsmap()})
output$bsprdsdst <- renderPlot({bsprdsdst()})
output$bsprdstab <- renderTable({bsprdstab()}, width = 900, digits = 3)
```

#### Map

This map shows the predicted likelihood of observing `r renderText({input$spsel})` for the selected prediction type (`r renderText({input$bsmettyp})`) under baseline `r renderText({names(bstypls)[unlist(bstypls) == as.character(input$bstyp)]})` conditions.  Each stream segment is colored by the estimated probability occurrence for the selected scenario. The color scale is the same for all selections to allow comparisons of relative changes in the estimates. A screenshot of the map or a tabular summary of the data can be downloaded by clicking the buttons below. 

```{r}
column(12, 
  column(4, downloadButtonRmd('dlbsprdsmap', 'Download map')),
  column(4, downloadButtonRmd('dlbsprdsdat', 'Download data'))
)
HTML('<br>')
HTML('<br>')
column(12, 
  leafletOutput('bsprdsmap', height = 700) %>% withSpinner()
)
```

#### Distribution summary

The range of predicted probabilities of occurrence from the map are summarized in the plot and table below.  The plot shows the probabilities summarized by all watersheds (left plot) and each watershed separately using [boxplots](https://en.wikipedia.org/wiki/Box_plot) overlaid on [violin plots](https://en.wikipedia.org/wiki/Violin_plot).  These plots provide an indication of where how the probability estimates are distributed in each watershed.  The table provides similar information.  Click on the buttons to download the plot or table. 

```{r}
column(12, 
  column(4, downloadButtonRmd('dlbsprdsdst', 'Download figure'))
)
column(12, plotOutput('bsprdsdst') %>% withSpinner())
column(12, 
  column(4, downloadButtonRmd('dlbsprdstab', 'Download table'))
)
column(12, tableOutput('bsprdstab') %>% withSpinner())
```

### Future scenarios {.tabset}

```{r}
column(width = 12,
       
       column(width = 4,
              
              # select metric type
              selectInput("clmmod", "Select climate model", choices = list('CanESM2' = 'CanESM2', 'CCSM4' = 'CCSM4', 'MIROC5' = 'MIROC5'))
       
        ),
       
       column(width = 4, 
              
              # select model year  
              selectInput("futyr", 'Select future year:', choices = c("2040" = '2040', "2100" = '2100'))
              
        ),
       
       column(width = 4, 
              
              # select prediction type year  
              selectInput("futmettyp", 'Select prediction type:', choices = c("Temperature" = 'temp', "Flow" = 'flow', 'Synthesis' = 'syn'), selected = 'syn')
              
        )
       
      
)
```
```{r}
output$futprdsmap <- renderLeaflet({futprdsmap()})
output$futprdsdst <- renderPlot({futprdsdst()})
output$futprdstab <- renderTable({futprdstab()}, width = 900, digits = 3)
```

#### Map

This map shows the predicted likelihood of observing `r renderText({input$spsel})` for the selected climate model (`r renderText({input$clmmod})`) and prediction type (`r renderText({input$futmettyp})`) under future conditions for the year `r renderText({input$futyr})`.  Each stream segment is colored by the estimated probability occurrence for the selected scenario. The color scale is the same for all selections to allow comparisons of relative changes in the estimates. A screenshot of the map or a tabular summary of the data can be downloaded by clicking the buttons below. 

```{r}
column(12, 
  column(4, downloadButtonRmd('dlfutprdsmap', 'Download map')),
  column(4, downloadButtonRmd('dlfutprdsdat', 'Download data'))
)
HTML('<br>')
HTML('<br>')
column(12, 
  leafletOutput('futprdsmap', height = 700) %>% withSpinner()
)
```

#### Distribution summary

The range of predicted probabilities of occurrence from the map are summarized in the plot and table below.  The plot shows the probabilities summarized by all watersheds (left plot) and each watershed separately using [boxplots](https://en.wikipedia.org/wiki/Box_plot) overlaid on [violin plots](https://en.wikipedia.org/wiki/Violin_plot).  These plots provide an indication of where how the probability estimates are distributed in each watershed.  The table provides similar information.  Click on the buttons to download the plot or table. 

```{r}
column(12, 
  column(4, downloadButtonRmd('dlfutprdsdst', 'Download figure'))
)
column(12, plotOutput('futprdsdst') %>% withSpinner())
column(12, 
  column(4, downloadButtonRmd('dlfutprdstab', 'Download table'))
)
column(12, tableOutput('futprdstab') %>% withSpinner())
```