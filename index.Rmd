---
self_contained: yes
output: 
  html_document:
    includes:
      in_header: cssloaders_in_header.html
runtime: shiny
---

## Biological responses of stream communities to climate change in the LA river basin {.tabset .tabset-pills}

```{r setup, include = FALSE}
# globals
library(knitr)
opts_chunk$set(echo = F, message = F, warning = F)

library(tidyverse)
library(sf)
library(mapview)
library(shiny)
library(leaflet)
library(stargazer)
library(shinycssloaders)
library(shinyWidgets)
library(patchwork)

source('R/funcs.R')

# rmd downloads
downloadButtonRmd <- function (outputId, label = "Download", class = NULL, ...)  {
  tags$a(id = outputId, class = paste("btn btn-default shiny-download-link", 
                                      class), href = "", target = "_blank", download = NA, 
         icon("download"), label, ...)
}

data(biodat)
data(rchdat)
data(allrchdat)
data(obsbiomet)
data(futest)
data(bsest)
data(wshed)

# color palette function for prob map
pal <- colorNumeric(
  palette = RColorBrewer::brewer.pal(11, 'RdYlBu'),
  na.color = NA,
  domain = c(0, 1)
)

# species choices
spls <- list('arroyo chub' = 'chub', 'arroyo toad' = 'toad', "least bell's vireo" = 'vireo', 'rainbow trout' = 'trout', 'santa ana sucker' = 'sucker', 'southwestern pond turtle' = 'turtle')

# watershed choices
sheds <- allrchdat %>% 
  pull(shed) %>% 
  levels

# map types
mptyps <- c("CartoDB.Positron", "CartoDB.DarkMatter", "OpenStreetMap", "Esri.WorldImagery", "OpenTopoMap")

# ggplot theme for dist plots
pdstthm <- theme_bw(base_family = 'serif', base_size = 16) + 
  theme(
    axis.title.x = element_blank(), 
    axis.text.x = element_text(hjust = 1, angle = 20)
  )
```

```{r reactives}
# species selection
sprct <- reactive({
  
  # input
  spsel <- input$spsel
  sheds <- input$sheds
  
  out <- biodat %>% 
    filter(spp %in% spsel) %>% 
    filter(shed %in% sheds)
  
  return(out)
  
})

# watershed selection
wshedsel <- reactive({
  
  # input
  sheds <- input$sheds
  
  out <- wshed %>% 
    filter(shed %in% sheds)
  
  return(out)
  
})

# reaches filtered by wshed
rchdatsel <- reactive({
  
  # inputs
  sheds <- input$sheds
  
  out <- rchdat %>% 
    filter(shed %in% sheds)
  
  return(out)
  
})

# all reaches filtered by wshed
allrchdatsel <- reactive({
  
  # inputs
  sheds <- input$sheds
  
  out <- allrchdat %>% 
    filter(shed %in% sheds)
  
  return(out)
  
})

# map of species data
spmap <- reactive({
  
  # input
  sprct <- sprct()
  rchdatsel <- rchdatsel()
  wshedsel <- wshedsel()
  
  # get pt size
  occex <- sprct$occex
  
  # colors
  cols <- c('tomato1', 'lightgreen')
  names(cols) <- c('absent', 'present')
  
  out <- mapview(wshedsel, homebutton = F, legend = F, color = 'black', col.regions = 'white', alpha = 0.6, map.types = mptyps) + 
    mapview(rchdatsel, homebutton = F, color = 'black', legend = F, lwd = 0.5, alpha = 0.5, layer = 'Reaches') + 
    mapview(sprct, zcol = 'occurrence', legend = T, col.regions = cols, cex = occex, homebutton = F, layer = 'Occurrence')

  return(out)
 
})

# metric data joined with biodat, biodat COMIDs filtered by rchdat COMID
spmtdat <- reactive({
  
  # input
  metsel <- input$metsel
  mettypobs <- input$mettypobs
  spsel <- input$spsel
    
  # minor format for output
  out <- obsbiomet %>% 
    filter(mettypobs %in% !!mettypobs) %>%
    filter(spp %in% spsel) %>% 
    filter(met %in% metsel) %>% 
    mutate(
      occurrence = factor(occurrence, levels = c('0', '1'), labels = c('absent', 'present')),
      occurrbin = case_when(
        occurrence %in% 'absent' ~ 0, 
        occurrence %in% 'present' ~ 1
      )
    ) 
  
  req(nrow(out) > 0)
  
  return(out)
  
})

# metric and biodata plot
spmtplt <- reactive({
  
  # input
  spmtdat <- spmtdat()
  metsel <- input$metsel
  
  req(metsel)

  p <- ggplot(spmtdat, aes(x = val, y = as.numeric(occurrbin))) +
    geom_point(aes(fill = occurrence), size = 4, alpha = 0.7, pch = 21) +
    scale_fill_manual('Occcurence', values = c('tomato1', 'lightgreen'), drop = FALSE) +
    geom_smooth(method = "glm", method.args = list(family = "binomial"), fullrange = T) +
    theme_bw(base_family = 'serif', base_size = 20) +
    theme(
      legend.title = element_blank(),
      strip.background = element_blank(),
      legend.position = 'top'
      ) +
    ylab('Pr. occurrence') + 
    xlab(metsel)
  
  return(p)
  
})

# regression mod for spmtplt and stargazer
spmtmod <- reactive({
  
  # inputs
  spmtdat <- spmtdat()
  metsel <- input$metsel
  
  # rename val to metric name for stargazer
  tomod <- spmtdat
  names(tomod)[names(tomod) %in% 'val'] <- metsel
  
  # make model
  mod <- paste('occurrbin', '~', metsel) %>% 
    as.formula %>% 
    glm(., tomod, family = 'binomial')
  
  return(mod)
  
})

# probability of occurrence predictions for species and baseline condition
bsprds <- reactive({

  # input
  spsel <- input$spsel
  bsmettyp <- input$bsmettyp
  bstyp <- input$bstyp
  rchdatsel <- rchdatsel()
  
  # filter baseline predictions
  out <- bsest %>% 
    filter(spp %in% spsel) %>% 
    filter(dts %in% bstyp) %>% 
    filter(bsmettyp %in% !!bsmettyp)
  
  # join with rchdatsel for filter
  out <- rchdatsel %>% 
    left_join(out, by = 'COMID')
  
  return(out)

})

# map of predictions by comid
bsprdsmap <- reactive({

  # input
  bsprds <- bsprds()
  wshedsel <- wshedsel()

  mapview(bsprds, layer.name = NULL) %>%
    .@map   %>% 
    clearMarkers() %>%
    clearShapes() %>%
    clearControls() %>%
    addPolygons(data = wshedsel(), opacity = 1, weight = 1, color = 'black', 
      fillOpacity = 0.6, fillColor = 'white', label = ~as.character(shed)
      ) %>% 
    addPolylines(data = bsprds, opacity = 1, weight = 1, color = ~pal(prd),
      label = ~as.character(round(prd, 2))
      ) %>% 
    addLegend(data = bsprds, "topright", pal = pal, values = ~prd,
              title = "Pr. occurence", opacity = 1
    )

})

# plot of baseline prediction distributions
bsprdsdst <- reactive({
  
  # inputs
  bsprds <- bsprds()

  # data to plot, plus median by group and all
  toplo <- bsprds %>%
    st_set_geometry(NULL) %>% 
    group_by(shed) %>% 
    mutate(
      medv = median(prd, na.rm = T)
      ) %>% 
    ungroup %>% 
    mutate(
      medvall = median(prd, na.rm = T)
      )
  
  # all 
  p1 <- ggplot(toplo, aes(x = 'All selected', y = prd, fill = medvall)) + 
    geom_violin(alpha = 0.8, colour = 'lightgrey') + 
    geom_boxplot(width = 0.1, fill = 'white', alpha = 0.1, outlier.shape = NA) + 
    labs(y = "Pr. occurrence") +
    scale_y_continuous(limits = c(0, 1)) +
    scale_fill_gradientn(colours = pal(seq(0, 1, length = 11)), limits = c(0, 1), guide = F) +
    pdstthm  
  
  # by watersheds
  p2 <- ggplot(toplo, aes(x = shed, y = prd, fill = medv)) + 
    geom_violin(alpha = 0.8, colour = 'lightgrey') + 
    geom_boxplot(width = 0.1, fill = 'white', alpha = 0.1, outlier.shape = NA) + 
    labs(y = NULL) +
    scale_y_continuous(limits = c(0, 1)) +
    scale_fill_gradientn(colours = pal(seq(0, 1, length = 11)), limits = c(0, 1), guide = F) +
    pdstthm
    
  p1 + p2 + plot_layout(ncol = 2, widths = c(0.2, 0.8))
  
})

# table data for baseline prediction distributions
bsprdstab <- reactive({
  
  # inputs
  bsprds <- bsprds()
  
  bsprds <- bsprds %>% 
    st_set_geometry(NULL)
  
  # all data summarized
  totaball <- bsprds %>%
    select(prd) %>% 
    summarise_all(funs(mean, median, min, max), na.rm = T) %>% 
    mutate(Watershed = 'All selected') %>% 
    select(Watershed, everything())
  
  # by shed
  totab <- bsprds %>%
    select(shed, prd) %>% 
    group_by(shed) %>% 
    summarise_all(funs(mean, median, min, max), na.rm = T) %>% 
    mutate(shed = as.character(shed)) %>% 
    rename(Watershed = shed) %>% 
    bind_rows(totaball, .) 
  
  return(totab)
  
})

# future predictions for selection
futprds <- reactive({
  
  # input
  spsel <- input$spsel
  clmmod <- input$clmmod
  futyr <- input$futyr
  futmettyp <- input$futmettyp
  allrchdatsel <- allrchdatsel()

  # filter predictions by selection
  out <- futest %>% 
    filter(spp %in% spsel) %>% 
    filter(mds %in% clmmod) %>% 
    filter(dts %in% futyr) %>% 
    filter(mettyp %in% futmettyp)
  
  # join with allrchdatsel for filter
  out <- allrchdatsel %>% 
    inner_join(out, by = 'COMID')
  
  return(out)
  
})

# map of predictions by comid 
futprdsmap <- reactive({
  
  # input
  futprds <- futprds()
  wshedsel <- wshedsel()

  mapview(futprds, layer.name = NULL) %>% 
    .@map %>% 
    clearMarkers() %>%
    clearShapes() %>%
    clearControls() %>%
    addPolygons(data = wshedsel(), opacity = 1, weight = 1, color = 'black', 
      fillOpacity = 0.6, fillColor = 'white', label = ~as.character(shed)
      ) %>% 
    addPolylines(data = futprds, opacity = 1, weight = 1, color = ~pal(prd),
      label = ~as.character(round(prd, 2))
      ) %>%
    addLegend(data = futprds, "topright", pal = pal, values = ~prd,
              title = "Pr. occurence", opacity = 1
    )

})

# plot of fture prediction distributions
futprdsdst <- reactive({
  
  # inputs
  futprds <- futprds()

  # data to plot, plus median by group and all
  toplo <- futprds %>%
    st_set_geometry(NULL) %>% 
    group_by(shed) %>% 
    mutate(
      medv = median(prd, na.rm = T)
      ) %>% 
    ungroup %>% 
    mutate(
      medvall = median(prd, na.rm = T)
      )
  
  # all 
  p1 <- ggplot(toplo, aes(x = 'All selected', y = prd, fill = medvall)) + 
    geom_violin(alpha = 0.8, colour = 'lightgrey') + 
    geom_boxplot(width = 0.1, fill = 'white', alpha = 0.1, outlier.shape = NA) + 
    labs(y = "Pr. occurrence") +
    scale_y_continuous(limits = c(0, 1)) +
    scale_fill_gradientn(colours = pal(seq(0, 1, length = 11)), limits = c(0, 1), guide = F) +
    pdstthm  
  
  # by watersheds
  p2 <- ggplot(toplo, aes(x = shed, y = prd, fill = medv)) + 
    geom_violin(alpha = 0.8, colour = 'lightgrey') + 
    geom_boxplot(width = 0.1, fill = 'white', alpha = 0.1, outlier.shape = NA) + 
    labs(y = NULL) +
    scale_y_continuous(limits = c(0, 1)) +
    scale_fill_gradientn(colours = pal(seq(0, 1, length = 11)), limits = c(0, 1), guide = F) +
    pdstthm
    
  p1 + p2 + plot_layout(ncol = 2, widths = c(0.2, 0.8))
  
})

# table data for future prediction distributions
futprdstab <- reactive({
  
  # inputs
  futprds <- futprds()
  
  futprds <- futprds %>% 
    st_set_geometry(NULL)
  
  # all data summarized
  totaball <- futprds %>%
    select(prd) %>% 
    summarise_all(funs(mean, median, min, max), na.rm = T) %>% 
    mutate(Watershed = 'All selected') %>% 
    select(Watershed, everything())
  
  # by shed
  totab <- futprds %>%
    select(shed, prd) %>% 
    group_by(shed) %>% 
    summarise_all(funs(mean, median, min, max), na.rm = T) %>% 
    mutate(shed = as.character(shed)) %>% 
    rename(Watershed = shed) %>% 
    bind_rows(totaball, .) 
  
  return(totab)
  
})
```

```{r downloadhandlers}
# map for observed species
output$dlspmap <- downloadHandler(
  filename = function(){'spmap.png'},
  content = function(file){
    mapshot(x = spmap(), file = file)
  }
)

# data for observed species
output$dlspdat <- downloadHandler(
  filename = function(){'spdat.csv'},
  content = function(file){
    # format for ambiguity
    todl <- sprct() %>% 
      st_set_geometry(NULL) %>% 
      group_by(spp, yr, shed, occurrence) %>% 
      summarise(count = n()) %>% 
      arrange(shed, yr, occurrence)
    write.csv(todl, file, quote = T, row.names = F)
  }
)

# plot for baseline prediction distributions
output$dlspmtplt <- downloadHandler(
  filename = function(){'spmtplt.png'},
  content = function(file){
    png(file, width = 7, height = 7, family = 'serif', units = 'in', res = 250)
    print(spmtplt())
    dev.off()
  }
)

# map for baseline predictions
output$dlbsprdsmap <- downloadHandler(
  filename = function(){'bsprdsmap.png'},
  content = function(file){
    mapshot(x = bsprdsmap(), file = file)
  }
)

# map data for baseline predictions
output$dlbsprdsdat <- downloadHandler(
  filename = function(){'bsprdsdat.csv'},
  content = function(file){
    todl <- bsprds() %>% st_set_geometry(NULL)
    write.csv(todl, file, quote = T, row.names = F)
  }
)

# plot for baseline prediction distributions
output$dlbsprdsdst <- downloadHandler(
  filename = function(){'bsprdsdst.png'},
  content = function(file){
    png(file, width = 10, height = 5, family = 'serif', units = 'in', res = 250)
    print(bsprdsdst())
    dev.off()
  }
)

# table data for baseline prediction distributions
output$dlbsprdstab <- downloadHandler(
  filename = function(){'bsprdstab.csv'},
  content = function(file){
    write.csv(bsprdstab(), file, quote = T, row.names = F)
  }
)

# map for future predictions
output$dlfutprdsmap <- downloadHandler(
  filename = function(){'futprdsmap.png'},
  content = function(file){
    mapshot(x = futprdsmap(), file = file)
  }
)

# map data for future predictions
output$dlfutprdsdat <- downloadHandler(
  filename = function(){'futprdsdat.csv'},
  content = function(file){
    todl <- futprds() %>% st_set_geometry(NULL)
    write.csv(todl, file, quote = T, row.names = F)
  }
)

# plot for future prediction distributions
output$dlfutprdsdst <- downloadHandler(
  filename = function(){'futprdsdst.png'},
  content = function(file){
    png(file, width = 10, height = 5, family = 'serif', units = 'in', res = 250)
    print(futprdsdst())
    dev.off()
  }
)

# table data for future prediction distributions
output$dlfutprdstab <- downloadHandler(
  filename = function(){'futprdstab.csv'},
  content = function(file){
    write.csv(futprdstab(), file, quote = T, row.names = F)
  }
)
```

```{r topsels}
column(12,

  column(4,
 
    # select species to show
    selectInput("spsel", "Choose species:", choices = spls)
    
  ),
  
  column(4,
    
    # select watershed
    pickerInput("sheds", label = 'Select watershed(s):', choices = sheds,
        options = list(`actions-box` = TRUE, size = 20), selected = sheds, multiple = TRUE)
    
  )
)    
```

### Overview

This website is an interactive tool to demonstrate riparian and stream community responses to changes in hydrology in the Los Angeles and Ventura County watersheds, California, USA.  Biological response was modelled as a function of baseline and projected changes in temperature and flow using historical data and expected flow changes from down-scaled climate change models. This website is provided to enhance understanding of climate change effects on riparian dependent species to facilitate management of watershed, riparian, and in-stream habitats. 

#### Objectives and approach 

The objective of this website is to present the project results in a way that is meaningful to the interests of the advisory committee and others that can benefit from this project.  The website is designed to address the following questions:

* What historical biological or baseline flow data are relevant for regulatory or management communities to understand current conditions? 

* What changes in biological communities and flow are relevant for regulatory or management decisions in the region?

* What sources of uncertainty are of most concern to inform decision-making processes?

The website is structured following an analysis workflow that describes the biology, modelled hydrology, and biological response to flow changes. Data can viewed using different selection widgets and downloaded in tabular or graphical format. __The tabs at the top of the website link to separate components of the analysis.__

1) __Observed biology__: View and download biology data for the Los Angeles and Ventura County watersheds, historical data from existing surveys

1) __Baseline conditions__: View results for baseline conditions and modelled species results for stream reaches in the study region

1) __Future scenarios__: View results for future scenarios and modelled species results for stream reaches in the study region

#### Attribution

All site content and analyses by [Marcus Beck](mailto:marcusb@sccwrp.org), with assistance from [Jenny Taylor](mailto:jennyt@sccwrp.org), [Abel Santana](mailto:abels@sccwrp.org), and [Eric Stein](mailto:erics@sccwrp.org). View the web page source content [here](https://github.com/SCCWRP/flowecology).

### Observed biology {.tabset}

#### Map

```{r}
# mapview
output$spmap <- renderLeaflet({spmap()@map})
```
```{r}
column(12, 
  column(4, downloadButtonRmd('dlspmap', 'Download map')),
  column(4, downloadButtonRmd('dlspdat', 'Download data'))
)
HTML('<br>')
HTML('<br>')
column(12, 
  leafletOutput('spmap', height = 700) %>% withSpinner()
)
```

#### Modelled response

```{r}
column(width = 12,

  column(width = 4,
        
        # select metric type
        selectInput("mettypobs", "Select predictor type:", choices = c('Flow', 'Temperature'))
  
  ),
  
  column(width = 4, 
        
        renderUI({
          
          # input
          mettypobs <- input$mettypobs
          spsel <- input$spsel

          # pull metrics to select based on input
          tosel <- obsbiomet %>%
            filter(mettypobs %in% !!mettypobs) %>% 
            filter(spp %in% spsel) %>% 
            pull(met) %>% 
            unique
        
          selectInput("metsel", "Select meric:", choices = tosel)
          
        })
        
  )
       
)
```

```{r}
output$spmtplt <- renderPlot({spmtplt()}, width = 500, height = 500)
output$spmtmodtab <- renderUI({
      
  # input
  spmtmod <- spmtmod()
  
  spmtmod %>%
    stargazer(., type = 'html', dep.var.labels = 'presence/absence') %>% 
    HTML
  
})
```
```{r}
column(12,
  column(width = 6, 
    plotOutput('spmtplt') %>% withSpinner()
  ), 
  column(width = 6,
    HTML('<br>'),
    uiOutput('spmtmodtab') %>% withSpinner(),
    HTML('<br><br>'), 
    downloadButtonRmd('dlspmtplt', 'Download figure')
  )
)
```

### Baseline conditions {.tabset}

```{r}
column(width = 12,

    column(width = 4,

          # select prediction type
          selectInput("bsmettyp", 'Select prediction type:', choices = c("Temperature" = 'temp', "Flow" = 'flow', 'Synthesis' = 'syn'), selected = 'syn')

    ),

    column(width = 4,
          
          # select baseline conditions
          selectInput('bstyp', 'Select baseline conditions:', choices = list(`dry (2014)` = '2014', `moderate (2010)` = '2010', `wet (1993)` = '1993'))

    )

)
```
```{r}
output$bsprdsmap <- renderLeaflet({bsprdsmap()})
output$bsprdsdst <- renderPlot({bsprdsdst()})
output$bsprdstab <- renderTable({bsprdstab()}, width = 900, digits = 3)
```

#### Map

```{r}
column(12, 
  column(4, downloadButtonRmd('dlbsprdsmap', 'Download map')),
  column(4, downloadButtonRmd('dlbsprdsdat', 'Download data'))
)
HTML('<br>')
HTML('<br>')
column(12, 
  leafletOutput('bsprdsmap', height = 700) %>% withSpinner()
)
```

#### Distribution summary

```{r}
column(12, 
  column(4, downloadButtonRmd('dlbsprdsdst', 'Download figure'))
)
column(12, plotOutput('bsprdsdst') %>% withSpinner())
column(12, 
  column(4, downloadButtonRmd('dlbsprdstab', 'Download table'))
)
column(12, tableOutput('bsprdstab') %>% withSpinner())
```

### Future scenarios {.tabset}

```{r}
column(width = 12,
       
       column(width = 4,
              
              # select metric type
              selectInput("clmmod", "Select climate model", choices = list('CanESM2' = 'CanESM2', 'CCSM4' = 'CCSM4', 'MIROC5' = 'MIROC5'))
       
        ),
       
       column(width = 4, 
              
              # select model year  
              selectInput("futyr", 'Select future year:', choices = c("2040" = '2040', "2100" = '2100'))
              
        ),
       
       column(width = 4, 
              
              # select prediction type year  
              selectInput("futmettyp", 'Select prediction type:', choices = c("Temperature" = 'temp', "Flow" = 'flow', 'Synthesis' = 'syn'), selected = 'syn')
              
        )
       
      
)
```
```{r}
output$futprdsmap <- renderLeaflet({futprdsmap()})
output$futprdsdst <- renderPlot({futprdsdst()})
output$futprdstab <- renderTable({futprdstab()}, width = 900, digits = 3)
```

#### Map

```{r}
column(12, 
  column(4, downloadButtonRmd('dlfutprdsmap', 'Download map')),
  column(4, downloadButtonRmd('dlfutprdsdat', 'Download data'))
)
HTML('<br>')
HTML('<br>')
column(12, 
  leafletOutput('futprdsmap', height = 700) %>% withSpinner()
)
```

#### Distribution summary

```{r}
column(12, 
  column(4, downloadButtonRmd('dlfutprdsdst', 'Download figure'))
)
column(12, plotOutput('futprdsdst') %>% withSpinner())
column(12, 
  column(4, downloadButtonRmd('dlfutprdstab', 'Download table'))
)
column(12, tableOutput('futprdstab') %>% withSpinner())
```